# grab_question1

#这是针对考试中第一题的算法

#算法文件为grab_question1.py

#测试文件为test_grab_question1.py

#python3环境下运行,需要下载pytest作为测试包.

#用法如下：将这两个文件下载到同一目录下，cmd 切换到这个目录，输入pytest即可

#测试用了如下的例子：

1.[1,2,3,3,4,5,5] n=6  结果应为[(1,5),(1,5),(2,4),(3,3)]

2.[1,2,3…,99] n=3结果应为[(1,2)]
              n=4结果应为[(1,3),(2,2)]
              ……
              n=100结果应为[(1,99),(2,98),…,(50,50)]
              
3.[1,1,2,2,3,3,4,4] n=6 结果应为[(2,4),(2,4),(2,4),(2,4),(3,3)]

4.[1,1,2,2,3,4,4] n=6 结果应为[(2,4),(2,4),(2,4),(2,4)]

5.[1,1,2,2,2,4,4,5,5] n=7 结果应为[(2,5),(2,5),(2,5),(2,5),(2,5),(2,5)]

6.[-3,-3,-2,-1,-1] n=-3 结果应为[(-2,-1),(-2,-1)]

7.[-3,-3,-2,-1,1,3] n=0 结果应为[(-3,3),(-3,3),(-1,1)]

8.[-3,-3,-2,-1,1,3] n=5 结果应为[]

#思考思路

#首先肯定不能通过遍历所有数对的方式，那样复杂度太高，为O（n2）

#考虑前后两头一起取数，若二者之和大于n，则让后面的往前推，若小于n，让前面的往后推。

#还要考虑到数的大小相同的问题。因此建立了一个字典，字典的key是从小到大排列的所有的数，value是每个数出现的个数。

#算法内容

#先建立字典，字典的key是从小到大排列的所有的数，value是每个数出现的个数。

#再看看n/2这个数有没有在字典里面。如果有，看看n/2的value，计算出可以配对的情况数，加入到结果。之后字典中删除n/2

#然后字典前后两头一起取数，若二者之和大于n，则让后面的往前推，若小于n，让前面的往后推。若等于n，计算这两个数可以构成的组合数，加入到结果。然后前面的数往后推。

#本算法复杂度为O（n）
